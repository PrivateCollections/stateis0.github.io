<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>并发编程之死锁解析</title></head><body>　　<div class="inner"><h2>并发编程之死锁解析</h2><p>在 Java 的并发编程中，有一个问题需要特别注意，那就是死锁，如果发生了死锁，基本就是重启，而重启将会丢失运行中的数据。所以，了解死锁的形成并排查死锁到预防死锁成了一个重要的问题。</p>
<p>我们了解任何一个事情的步骤是：what，how，why，why not。</p>
<h2 id="1-什么是死锁？"><a href="#1-什么是死锁？" class="headerlink" title="1. 什么是死锁？"></a>1. 什么是死锁？</h2><p>我们还是直接写一段代码来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">new</span> DeadLock().resource1();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">new</span> DeadLock().resource2();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resource1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="string">"resource1"</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"获取资源1"</span>);</span><br><span class="line">       <span class="comment">// 等待 1 秒让另一个线程拿到锁</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      resource2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resource2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="string">"resource2"</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"获取资源2"</span>);</span><br><span class="line">      <span class="comment">// 等待 1 秒让另一个线程拿到锁</span></span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      resource1();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们启用了两个线程，分别抢占2个资源，但这两个资源又分别被不同的对象（字符串）锁住了。当第一个线程调用 resource1 方法，进入同步块，拿到锁，并等待 1 秒钟让另一个线程进入 resource2 同步块，当第二个线程进入同步块后，注意：此时， 拿着 resourec1 锁的线程企图拿到 resource2 的锁，但这个时候，拿着 resource2 的线程也想去拿 resource1 的锁。于是就出现了互相僵持的情况，谁也无法拿到对方的锁，整个系统就卡死了。</p>
<p>这种情况就是死锁。</p>
<p>像我们现在写的代码是自己故意造出来的死锁，我们能够发现，那如果是线上环境怎么办，假如我们的系统卡死了，我们怎么知道到底是哪一段代码出现了问题，有没有可能使死锁的问题。也就是如何检测死锁。</p>
<h2 id="2-如何检测死锁？"><a href="#2-如何检测死锁？" class="headerlink" title="2. 如何检测死锁？"></a>2. 如何检测死锁？</h2><p>由于死锁极难通过人工的方式查出来，因此JDK 提供了命令来检测某个java进程中心线程的情况，并排查有没有死锁。上面命令呢？ jps , 用来查看java 程序的进程号，当然在 Linux 中也可以通过别的方式获取，   jstack <code>进程号</code>命令则可以答应对应进程的栈信息，并找到死锁。</p>
<p>我们就刚刚的程序，在 windows 上使用该命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\stateis0&gt;jps</span><br><span class="line"><span class="number">11060</span></span><br><span class="line"><span class="number">2084</span> Launcher</span><br><span class="line"><span class="number">10712</span> RemoteMavenServer</span><br><span class="line"><span class="number">18040</span> Jps</span><br><span class="line"><span class="number">11820</span> DeadLock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\stateis0&gt;jstack <span class="number">11820</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">12</span>-<span class="number">29</span> <span class="number">18</span>:<span class="number">52</span>:<span class="number">38</span></span><br><span class="line"><span class="function">Full thread dump Java <span class="title">HotSpot</span><span class="params">(TM)</span> Client <span class="title">VM</span> <span class="params">(<span class="number">25.131</span>-b11 mixed mode)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"DestroyJavaVM" #11 prio</span>=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x051fe800</span> nid=<span class="number">0x1e0c</span> waiting on condition [<span class="number">0x00000000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Thread-1" #10 prio=5 os_prio=0 tid=0x18777800 nid=0x5664 waiting for monitor entry [0x18e0f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">43</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">1</span>(DeadLock.java:<span class="number">20</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">2</span>/<span class="number">4983748</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">"Thread-0" #9 prio=5 os_prio=0 tid=0x18776c00 nid=0x4dc4 waiting for monitor entry [0x18d7f000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">41</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">33</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">0</span>(DeadLock.java:<span class="number">11</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">1</span>/<span class="number">5592464</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">"Service Thread" #8 daemon prio=9 os_prio=0 tid=0x186e4c00 nid=0x172c runnable [0x00000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread0" #7 daemon prio=9 os_prio=2 tid=0x186af000 nid=0x53f8 waiting on condition [0x00000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Monitor Ctrl-Break" #6 daemon prio=5 os_prio=0 tid=0x1861e800 nid=0x3928 runnable [0x18b3f000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:<span class="number">116</span>)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">171</span>)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:<span class="number">141</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="number">284</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="number">326</span>)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="number">178</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x07861da0</span>&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.InputStreamReader.read(InputStreamReader.java:<span class="number">184</span>)</span><br><span class="line">        at java.io.BufferedReader.fill(BufferedReader.java:<span class="number">161</span>)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">324</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x07861da0</span>&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">389</span>)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMainV2$<span class="number">1</span>.run(AppMainV2.java:<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x179c0800 nid=0x40a0 waiting on condition [0x00000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x17985c00 nid=0x5004 runnable [0x00000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x17972400 nid=0x41a8 in Object.wait() [0x17cff000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x0ca1b830</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">143</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0ca1b830</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">164</span>)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">209</span>)</span><br><span class="line"></span><br><span class="line">"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x17960000 nid=0x4ef0 in Object.wait() [0x17c6f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;<span class="number">0x0ca1b9d0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br><span class="line">        - locked &lt;<span class="number">0x0ca1b9d0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Thread"</span> os_prio=<span class="number">2</span> tid=<span class="number">0x1795a800</span> nid=<span class="number">0x3f54</span> runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Periodic Task Thread"</span> os_prio=<span class="number">2</span> tid=<span class="number">0x18739400</span> nid=<span class="number">0x4a14</span> waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: <span class="number">229</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个死锁</span></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x17978de4</span> (object <span class="number">0x07415a50</span>, a java.lang.String),</span><br><span class="line">  which is held by <span class="string">"Thread-0"</span></span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x1797a974</span> (object <span class="number">0x0742bd18</span>, a java.lang.String),</span><br><span class="line">  which is held by <span class="string">"Thread-1"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">31</span>)</span><br><span class="line">         <span class="comment">// 等待 0x07415a50 锁</span></span><br><span class="line">        - waiting to lock &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">43</span>)</span><br><span class="line">        <span class="comment">// 持有 0x0742bd18</span></span><br><span class="line">        - locked &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">1</span>(DeadLock.java:<span class="number">20</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">2</span>/<span class="number">4983748</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">        at hello.DeadLock.resource2(DeadLock.java:<span class="number">41</span>)</span><br><span class="line">        <span class="comment">// 等待 0x0742bd18 锁</span></span><br><span class="line">        - waiting to lock &lt;<span class="number">0x0742bd18</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.resource1(DeadLock.java:<span class="number">33</span>)</span><br><span class="line">        <span class="comment">// 持有 0x07415a50</span></span><br><span class="line">        - locked &lt;<span class="number">0x07415a50</span>&gt; (a java.lang.String)</span><br><span class="line">        at hello.DeadLock.lambda$main$<span class="number">0</span>(DeadLock.java:<span class="number">11</span>)</span><br><span class="line">        at hello.DeadLock$$Lambda$<span class="number">1</span>/<span class="number">5592464</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发现了一个死锁</span></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\stateis0&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Thread-1  waiting to lock <0x07415a50>      locked <0x0742bd18><br>Thread-0  waiting to lock <0x0742bd18>       locked <0x07415a50> </0x07415a50></0x0742bd18></0x0742bd18></0x07415a50></p>
</blockquote>
<p>我们首先使用 jps 命令找到 java 进程号，然后使用 jstack <code>进程号</code> 打印进程栈的信息，其中，在最后的部分，jstack 告诉我们，他找到了一个死锁，其中又详细的信息：Thread-1 线程（这里我们没有给线程其合适的名字，如果在线上，给线程起一个合适的名字将更有利于排查）持有 String 类型的编号为 0x07415a50 的锁，等待编号为 0x07415a50 的锁 ， 但这个锁由 Thread-0 持有，于此同时，Thread-0 和 Thread-1 相反。Thread-0 线程持有 0x07415a50 的锁，等待 0x07415a50 的锁。我们的注释里也写上了。</p>
<p>那么发生了死锁，该怎么办呢？最简单的办法就是重启，重启之后，对 jstack 中打印的堆栈信息中的代码进行修改。重新发布。当然还有一些高级策略，比如让进程回滚到死锁前的状态，然后让他们顺序进入同步块。</p>
<h2 id="3-死锁有哪些形成的原因"><a href="#3-死锁有哪些形成的原因" class="headerlink" title="3. 死锁有哪些形成的原因"></a>3. 死锁有哪些形成的原因</h2><p>一般来说，要出现死锁问题需要满足以下条件：</p>
<ol>
<li><p>互斥条件：一个资源每次只能被一个线程使用。</p>
</li>
<li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
</li>
<li><p>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</p>
</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
</li>
</ol>
<p>死锁是由四个必要条件导致的，所以一般来说，只要破坏这四个必要条件中的一个条件，死锁情况就应该不会发生。</p>
<p>如果想要打破互斥条件，我们需要允许进程同时访问某些资源，这种方法受制于实际场景，不太容易实现条件；</p>
<p>打破不可抢占条件，这样需要允许进程强行从占有者那里夺取某些资源，或者简单一点理解，占有资源的进程不能再申请占有其他资源，必须释放手上的资源之后才能发起申请，这个其实也很难找到适用场景；</p>
<p>进程在运行前申请得到所有的资源，否则该进程不能进入准备执行状态。这个方法看似有点用处，但是它的缺点是可能导致资源利用率和进程并发性降低；</p>
<p>避免出现资源申请环路，即对资源事先分类编号，按号分配。这种方式可以有效提高资源的利用率和系统吞吐量，但是增加了系统开销，增大了进程对资源的占用时间。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>并发编程中的坑很多，尤其死锁，造成的问题基本只能靠重启来解决，如果遇到了数据保存在内存中但没有持久化的话，那么重启将出现很大的问题。因此我们在用锁的时候，一定要小心。避免出现死锁，如果出现了死锁，则可以使用 jstack 命令查看线程是否有死锁。用以排查问题。</p>
<p>总之并发的坑很多，楼主以后将会多多分析。</p>
<p>good luck  ！！！！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>