<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>分布式理论（三）——-一致性协议之-2PC</title></head><body>　　<div class="inner"><h2>分布式理论（三）——-一致性协议之-2PC</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-618e6eaec6367296.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了使系统尽量能够达到 CAP，于是有了 BASE 协议，而 BASE 协议是在可用性和一致性之间做的取舍和妥协。</p>
<p>人们往往需要在系统的可用性和数据一致性之间反复的权衡。于是呢，就产生我们标题中的一致性协议，而且还不止一个呢。</p>
<p>为了解决分布式问题，涌现了很多经典的算法和协议，最著名的就是二阶段提交协议，三阶段提交协议，Paxos 算法。</p>
<p>本文重点介绍二阶段提交协议，简称 2PC。</p>
<h2 id="1-什么是-2PC"><a href="#1-什么是-2PC" class="headerlink" title="1. 什么是 2PC"></a>1. 什么是 2PC</h2><p>在分布式系统中，会有多个机器节点，因此需要一个 “协调者” ，而各个节点就是 “参与者”，协调者统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点就是 “参与者”。</p>
<p>协调者最终决定这些参与者是否要把事务真正进行提交。正式基于这个思想，有了二阶段提交和 三阶段提交。</p>
<p>2PC ，不是 2 个 pc 机的意思，而是 Two-Phase Commit 。可以认为是一种算法，也可以认为是一种协议，主要目的就是为了保证分布式系统数据的一致性。</p>
<p>协议说明：顾名思义，二阶段提交就是讲事务的提交过程分成了两个阶段来进行处理。流程如下：</p>
<h2 id="2-2PC-阶段一"><a href="#2-2PC-阶段一" class="headerlink" title="2. 2PC 阶段一"></a>2. 2PC 阶段一</h2><h5 id="1-事务询问"><a href="#1-事务询问" class="headerlink" title="1. 事务询问"></a>1. 事务询问</h5><p>协调者向所有的参与者询问，是否准备好了执行事务，并开始等待各参与者的响应。</p>
<h5 id="2-执行事务"><a href="#2-执行事务" class="headerlink" title="2. 执行事务"></a>2. 执行事务</h5><p>各参与者节点执行事务操作，并将 Undo 和 Redo 信息记入事务日志中</p>
<h5 id="3-各参与者向协调者反馈事务询问的响应"><a href="#3-各参与者向协调者反馈事务询问的响应" class="headerlink" title="3. 各参与者向协调者反馈事务询问的响应"></a>3. 各参与者向协调者反馈事务询问的响应</h5><p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行；如果参与者没有成功执行事务，就返回 No 给协调者，表示事务不可以执行。</p>
<p>从上面可以感觉到，这个一个 所谓的 “投票阶段”，什么意思呢？所有的节点都投票决定是否执行事务操作。</p>
<h2 id="3-2PC-阶段二"><a href="#3-2PC-阶段二" class="headerlink" title="3. 2PC 阶段二"></a>3. 2PC 阶段二</h2><p>在阶段二中，会根据阶段一的投票结果执行 2 种操作：执行事务提交，中断事务。</p>
<p><strong>执行事务提交步骤如下：</strong></p>
<ol>
<li>发送提交请求：协调者向所有参与者发出 commit 请求。</li>
<li>事务提交：参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资源。</li>
<li>反馈事务提交结果：参与者在完成事务提交之后，向协调者发送 Ack 信息。</li>
<li>协调者接收到所有参与者反馈的 Ack 信息后，完成事务。</li>
</ol>
<p><strong>中断事务步骤如下：</strong></p>
<ol>
<li>发送回滚请求：协调者向所有参与者发出 Rollback 请求。</li>
<li>事务回滚：参与者接收到 Rollback 请求后，会利用其在阶段一种记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，想协调者发送 Ack 信息。</li>
<li>中断事务：协调者接收到所有参与者反馈的 Ack 信息后，完成事务中断。</li>
</ol>
<p>从上面的逻辑可以看出，二阶段提交就做了2个事情：投票，执行。</p>
<blockquote>
<p>核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看成一个强一致性的算法。</p>
</blockquote>
<p>整个事务的执行过程如图（可能不是太直观。。。。）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4ca515b5cd0c4fef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="4-优点缺点"><a href="#4-优点缺点" class="headerlink" title="4. 优点缺点"></a>4. 优点缺点</h2><p>优点：原理简单，实现方便<br>缺点：同步阻塞，单点问题，数据不一致，过于保守</p>
<ol>
<li>同步阻塞：</li>
</ol>
<p>在二阶段提交的过程中，所有的节点都在等待其他节点的响应，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。</p>
<ol start="2">
<li>单点问题：</li>
</ol>
<p>协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转，更重要的是：其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。</p>
<ol start="3">
<li>数据不一致：</li>
</ol>
<p>假设当协调者向所有的参与者发送 commti 请求之后，发生了局部网络异常或者是协调者在尚未发送完所有 commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 commit 请求。这将导致严重的数据不一致问题。</p>
<ol start="4">
<li>过于保守：</li>
</ol>
<p>如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的化，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，<strong>二阶段提交协议没有设计较为完善的容错机制，任意一个节点是失败都会导致整个事务的失败</strong>。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>由于 Base 理论需要在一致性和可用性方面做出权衡，因此涌现了很多关于一致性的算法或者说协议，这些协议设计的目的，就是能让分布式系统能够在可用性和一致性之间取得一个很好的平衡，能够基本可用。 比如 2PC，two-phase commit，分为两个阶段提交一个事务：投票，执行。通过协调者和各个参与者的配合，实现一致性协议。</p>
<p>当然，他也是有去缺点的，比如同步阻塞的时候性能较低，协调者的单点问题，网络故障可能引起的数据不一致的问题，执行策略过于保守的问题等等。</p>
<p>这些问题，将在另一个算法 3PC 中解决。我们将在下一篇文章中详细说明。</p>
<p>good luck！！！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>