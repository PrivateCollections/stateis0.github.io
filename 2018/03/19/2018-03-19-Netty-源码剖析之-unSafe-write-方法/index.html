<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>Netty-源码剖析之-unSafe-write-方法</title></head><body>　　<div class="inner"><h2>Netty-源码剖析之-unSafe-write-方法</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在  <a href="https://www.jianshu.com/p/bb579eb4fadd" target="_blank" rel="noopener">Netty 源码剖析之 unSafe.read 方法</a> 一文中，我们研究了 read 方法的实现，这是读取内容到容器，再看看 Netty 是如何将内容从容器输出 Channel 的吧。</p>
<h2 id="1-ctx-writeAndFlush-方法"><a href="#1-ctx-writeAndFlush-方法" class="headerlink" title="1. ctx.writeAndFlush 方法"></a>1. ctx.writeAndFlush 方法</h2><p>当我们调用此方法时，会从当前节点找上一个 outbound 节点，进行，并调用下个节点的 write 方法。具体看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> writeAndFlush(msg, newPromise()); <span class="comment">// 创建了一个默认的 DefaultChannelPromise 实例，返回的就是这个实例。</span></span><br><span class="line"></span><br><span class="line">@<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">true</span>)) &#123;<span class="comment">//判断 promise 有效性</span></span><br><span class="line">        ReferenceCountUtil.release(msg);<span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write(msg, <span class="keyword">true</span>, promise);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的就是 @3 方法。找到上一个 outbound 节点，判断他的节点是否时当前线程。如果是，则会直接调用，泛着，将后面的工作封装成一个任务放进 mpsc 队列，供当前线程稍后执行。这个 任务的 run 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_TASK_SIZE_ON_SUBMIT) &#123;</span><br><span class="line">            ctx.pipeline.decrementPendingOutboundBytes(size);</span><br><span class="line">        &#125;</span><br><span class="line">        write(ctx, msg, promise);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ctx = <span class="keyword">null</span>;</span><br><span class="line">        msg = <span class="keyword">null</span>;</span><br><span class="line">        promise = <span class="keyword">null</span>;</span><br><span class="line">        handle.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ctx.invokeWrite(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终执行的是 invokeWrite 方法。</p>
<p>我们看看如果直接执行会如何处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeWriteAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        invokeWrite0(msg, promise);</span><br><span class="line">        invokeFlush0();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeAndFlush(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先执行 invokeWrite0 方法进行 write，然后 flush。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e09ae6d795112fa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-f0c987de5b04d088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@2"></p>
<p>最终执行的是 unSafe 的 write 方法。<strong>注意：当前节点已经到了 Head 节点。</strong></p>
<p>详细说说该方法。</p>
<h2 id="2-unSafe-的-write-方法"><a href="#2-unSafe-的-write-方法" class="headerlink" title="2. unSafe  的 write 方法"></a>2. unSafe  的 write 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = <span class="keyword">this</span>.outboundBuffer;</span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法步骤如下：</p>
<ol>
<li>判断 outboundBuffer 有效性。</li>
<li>将 ByteBuf 过滤成池化或者线程局部直接内存（如果不是直接内存的话）。</li>
<li>预估当前 ByteBuf 大小（就是可读字节数）。</li>
<li>将 ByteBuf 包装成一个 Entry 节点放入到 outboundBuffer 的单向链表中。</li>
</ol>
<p>这里有一个地方需要注意一下， filterOutboundMessage 方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-ee8f5fbb83da5912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>如果是直接内存的话，就直接返回了 ，反之调用 newDirectBuffer 方法。我们猜想肯定是重新包装成直接内存，利用直接内存令拷贝的特性，提升性能。</p>
<p>看看该方法内部逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(ByteBuf buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> readableBytes = buf.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes == <span class="number">0</span>) &#123;</span><br><span class="line">        ReferenceCountUtil.safeRelease(buf);</span><br><span class="line">        <span class="keyword">return</span> Unpooled.EMPTY_BUFFER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator alloc = alloc();</span><br><span class="line">    <span class="keyword">if</span> (alloc.isDirectBufferPooled()) &#123;</span><br><span class="line">        ByteBuf directBuf = alloc.directBuffer(readableBytes);</span><br><span class="line">        directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);</span><br><span class="line">        ReferenceCountUtil.safeRelease(buf);</span><br><span class="line">        <span class="keyword">return</span> directBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf directBuf = ByteBufUtil.threadLocalDirectBuffer();</span><br><span class="line">    <span class="keyword">if</span> (directBuf != <span class="keyword">null</span>) &#123;</span><br><span class="line">        directBuf.writeBytes(buf, buf.readerIndex(), readableBytes);</span><br><span class="line">        ReferenceCountUtil.safeRelease(buf);</span><br><span class="line">        <span class="keyword">return</span> directBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocating and deallocating an unpooled direct buffer is very expensive; give up.</span></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先判断可读字节数，如果是0，之际返回一个空的 Buffer。</li>
<li>获取该 Channel 的 ByteBufAllocator ，如果是直接内存且池化，则分配一个直接内存，将旧的 Buffer 写入到新的中，释放旧的 Buffer。返回新的直接内存 Buffer。</li>
<li>反之，从 FastThreadLocal 中返回一个可重用的直接内存 Buffer，后面和上面的操作一样，写入，删除旧的，返回新的。注意，这里返回的可重用的 Buffer，当调用他的 release 方法的时候，实际上是归还到了 FastThreadLocal 中。对象池的最佳实践。</li>
</ol>
<p>关于 addMessage 方法，我们将在另一篇文章<a href="http://thinkinjava.cn/articles/2018/03/18/1521380047606.html" target="_blank" rel="noopener">Netty 出站缓冲区 ChannelOutboundBuffer 源码解析（isWritable 属性的重要性）</a>详细阐述，这里只需要知道，他放入了一个 出站缓存中就行了。</p>
<h2 id="3-unSafe-的-flush-方法"><a href="#3-unSafe-的-flush-方法" class="headerlink" title="3. unSafe 的 flush 方法"></a>3. unSafe 的 flush 方法</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-15438cc4bf67d74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>重点是 outboundBuffer.addFlush() 方法和 flush0 方法。</p>
<p>这两个方法在 <a href="http://thinkinjava.cn/articles/2018/03/18/1521380047606.html" target="_blank" rel="noopener">Netty 出站缓冲区 ChannelOutboundBuffer 源码解析（isWritable 属性的重要性）</a></p>
<p>这里只需要知道，addFlush 方法将刚刚添加进出站 buffer 的数据进行检查，并准备写入 Socket。<br>flush0 做真正的写入操作，其中，调用了 JDK 的 Socket 的 write 方法，将 ByteBuf 封装的 ByteBuffer 写到 Socket 中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到，数据真正的写出还是调用了 head 的节点中 unsafe 的 write 方法和 flush 方法，其中，write 只是将数据写入到了出站缓冲区，并且，write 方法可以调用多次，flush 才是真正的写入到 Socket。而更详细的细节，可以查看我的另一篇文章<a href="http://thinkinjava.cn/articles/2018/03/18/1521380047606.html" target="_blank" rel="noopener">Netty 出站缓冲区 ChannelOutboundBuffer 源码解析（isWritable 属性的重要性）</a>。</p>
<p>good luck ！！！！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>