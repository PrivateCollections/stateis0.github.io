<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>Netty-内存回收之-noCleaner-策略</title></head><body>　　<div class="inner"><h2>Netty-内存回收之-noCleaner-策略</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-d1c7aa1b05f873a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于堆外内存，使用 System.gc() 是不靠谱的，依赖老年代 FGC 也是不靠谱的，而且大部分调优指南都设置了 -DisableExplicitGC 禁用 System.gc()。所以主动回收比较靠谱， JDK 在 DirectByteBuffer 中提供了 Cleaner 用来主动释放内存。同时还有 Unsafe 的 freeMemory 方法也可以。 下面看看他是怎么做的。这里以非池化创建直接内存为例。</p>
<h2 id="UnpooledByteBufAllocator-newDirectBuffer-方法"><a href="#UnpooledByteBufAllocator-newDirectBuffer-方法" class="headerlink" title="UnpooledByteBufAllocator  newDirectBuffer 方法"></a>UnpooledByteBufAllocator  newDirectBuffer 方法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        buf = noCleaner ? <span class="keyword">new</span> InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">                <span class="keyword">new</span> InstrumentedUnpooledUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = <span class="keyword">new</span> InstrumentedUnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> disableLeakDetector ? buf : toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键点在于 noCleaner 的结果。影响其结果的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector, <span class="keyword">boolean</span> tryNoCleaner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(preferDirect);</span><br><span class="line">    <span class="keyword">this</span>.disableLeakDetector = disableLeakDetector;</span><br><span class="line">    noCleaner = tryNoCleaner &amp;&amp; PlatformDependent.hasUnsafe()</span><br><span class="line">            &amp;&amp; PlatformDependent.hasDirectBufferNoCleanerConstructor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tryNoCleaner 结果来自 PlatformDependent.useDirectBufferNoCleaner()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnpooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">boolean</span> disableLeakDetector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(preferDirect, disableLeakDetector, PlatformDependent.useDirectBufferNoCleaner());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否含有 DirectByteBuffer 构造器，有则 true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">useDirectBufferNoCleaner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> USE_DIRECT_BUFFER_NO_CLEANER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据是否含有 DirectByteBuffer 的构造器判断，如果没有，USE_DIRECT_BUFFER_NO_CLEANER=false</span></span><br><span class="line"><span class="keyword">if</span> (maxDirectMemory == <span class="number">0</span> || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) &#123;</span><br><span class="line">    USE_DIRECT_BUFFER_NO_CLEANER = <span class="keyword">false</span>;</span><br><span class="line">    DIRECT_MEMORY_COUNTER = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    USE_DIRECT_BUFFER_NO_CLEANER = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxDirectMemory &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxDirectMemory = maxDirectMemory0();</span><br><span class="line">        <span class="keyword">if</span> (maxDirectMemory &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            DIRECT_MEMORY_COUNTER = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DIRECT_MEMORY_COUNTER = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DIRECT_MEMORY_COUNTER = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 DirectByteBuffer 的构造器</span></span><br><span class="line"><span class="keyword">final</span> ByteBuffer direct;</span><br><span class="line">Constructor&lt;?&gt; directBufferConstructor;</span><br><span class="line"><span class="keyword">long</span> address = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object maybeDirectBufferConstructor =</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">final</span> Constructor&lt;?&gt; constructor =</span><br><span class="line">                                direct.getClass().getDeclaredConstructor(<span class="keyword">long</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">                        Throwable cause = ReflectionUtil.trySetAccessible(constructor, <span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> cause;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> constructor;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            ((Constructor&lt;?&gt;) maybeDirectBufferConstructor).newInstance(address, <span class="number">1</span>);</span><br><span class="line">            directBufferConstructor = (Constructor&lt;?&gt;) maybeDirectBufferConstructor;</span><br><span class="line">         </span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address != -<span class="number">1</span>) &#123;</span><br><span class="line">        UNSAFE.freeMemory(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DIRECT_BUFFER_CONSTRUCTOR = directBufferConstructor;</span><br></pre></td></tr></table></figure>
<p>noCleaner  为 true：创建 InstrumentedUnpooledUnsafeNoCleanerDirectByteBuf 对象。简称 noCleaner；<br>noCleaner  为false：创建 InstrumentedUnpooledUnsafeDirectByteBuf 对象。简称 hasCleaner；</p>
<p><strong>两者构造器方式不同：</strong></p>
<blockquote>
<p>noCleaner 反射调用 private DirectByteBuffer(long addr, int cap)<br>hasCleaner new 操作调用 DirectByteBuffer(int cap)</p>
</blockquote>
<p><strong>两个释放内存方式不同:</strong></p>
<blockquote>
<p>noCleaner  使用 unSafe.freeMemory(address);<br>hasCleaner  使用 DirectByteBuffer 的 Cleaner 的 clean 方法。</p>
</blockquote>
<p><strong>hasCleaner   的 clean 方法有 2 种策略：</strong></p>
<blockquote>
<p> 1.Java9 使用 Unsafe 的 invokeCleaner 方法。调用了 ByteBuffer 的 Cleaner 的 clean 方法。</p>
<pre><code>2. Java6 --- Java9 使用 DirectByteBuffer 的 属性 Cleaner 的 clean 方法。
</code></pre></blockquote>
<p><strong>clean 方法原理:</strong></p>
<blockquote>
<p>这个 clean 方法内部调用了一个名为 thunk 的 Deallocator 线程的 run 方法。该线程对象在创建 DirectByteBuffer 的时候同时创建。该线程的 run 方法内部会调用 unsafe 的 freeMemory 方法，同时还会调用 Bits.unreserveMemory 方法，该方法会相应的减小已经使用的内存大小数字（因为，每次申请直接内存都需要 Bits 判断是否足够，如果 FGC 后还不够，OOM，所以，这里的做法还是挺重要的）</p>
</blockquote>
<blockquote>
<p>注意：这个 Cleaner 是个虚引用，DirectByteBuffer  创建他的时候，会将自己放入虚引用的构造函数中，如果这个 DirectByteBuffer  被回收了（无人再引用这个 Cleaner），那么 GC 将会把这个 Cleaner 赋值给 Reference 的 pending 变量中，专门有一条 ReferenceHandler 的线程会死循环执行 Reference 的 tryHandlePending 方法，这个方法会调用 pending 的 clean 方法，完成内存回收操作。</p>
</blockquote>
<p><strong>这是 cleaner 对象的构造时机：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里构造 cleaner</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p><strong>该构造只有一个 int 参数</strong></p>
<p>所以，你知道了吧，noCleaner 的构造方法是不能调用 cleaner 的 clean 方法的。只能使用 unSafe 的 freeMemory 方法。而这就是 Netty 默认的做法。</p>
<p>同时，noCleaner  的构造方法也没有向 Bits 申请内存的内容，在申请内存的时候，性能会比 hasCleaner  要好一点。关于 Bits 的设计，我觉得不够优雅。当内存不够了，就 System.gc()，却只休眠 100 毫秒。根本不够回收到堆外内存。</p>
<p>实际上，Cleaner 的作用除了更新一下 Bits 的一些属性，方便下次申请内存之外，别无作用。</p>
<p>我猜想 Netty 使用 noCleaner  是性能优化的考虑吧。为了防止用户忘记使用 ReferenceCountUtil.release（）， 导致内存泄漏，Netty 还使用了虚引用跟踪每一个 ByteBuf，基本上避免了内存泄漏的发生。</p>
<p>综上所述：noCleaner  无论是在申请内存还是释放内存都比使用 hasCleaner  性能好要好一点。</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>