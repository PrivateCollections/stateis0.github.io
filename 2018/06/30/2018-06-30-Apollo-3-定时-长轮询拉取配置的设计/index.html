<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>Apollo-3-定时-长轮询拉取配置的设计</title></head><body>　　<div class="inner"><h2>Apollo-3-定时-长轮询拉取配置的设计</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-b852957c3897832b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Apollo 基础模型"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如上图所示，Apollo portal 更新配置后，进行轮询的客户端获取更新通知，然后再调用接口获取最新配置。不仅仅只有轮询，还有定时更新（默认 5 分钟一次）。目的就是让客户端能够稳定的获取到最新的配置。</p>
<p>一起来看看他的设计。</p>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p>具体的类是 <code>RemoteConfigRepository</code>，每一个 Config —— 也就是 namespace 都有一个 RemoteConfigRepository 对象，表示这个 Config 的远程配置仓库，可以利用这个仓库请求远程服务，得到配置。</p>
<p>RemoteConfigRepository 的构造方法需要一个 <code>namespace</code> 字符串，表明这个 Repository 所属的 Config 名称。</p>
<p>下面是该类的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RemoteConfigRepository</span><span class="params">(String namespace)</span> </span>&#123;</span><br><span class="line">    m_namespace = namespace;<span class="comment">// Config 名称</span></span><br><span class="line">    m_configCache = <span class="keyword">new</span> AtomicReference&lt;&gt;(); <span class="comment">//  Config 引用</span></span><br><span class="line">    m_configUtil = ApolloInjector.getInstance(ConfigUtil.class);<span class="comment">// 单例的 config 配置,存放 application.properties</span></span><br><span class="line">    m_httpUtil = ApolloInjector.getInstance(HttpUtil.class);<span class="comment">// HTTP 工具</span></span><br><span class="line">    m_serviceLocator = ApolloInjector.getInstance(ConfigServiceLocator.class);<span class="comment">// 远程服务 URL 更新类</span></span><br><span class="line">    remoteConfigLongPollService = ApolloInjector.getInstance(RemoteConfigLongPollService.class);<span class="comment">// 长轮询服务</span></span><br><span class="line">    m_longPollServiceDto = <span class="keyword">new</span> AtomicReference&lt;&gt;();<span class="comment">// 长轮询发现的当前配置发生变化的服务</span></span><br><span class="line">    m_remoteMessages = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    m_loadConfigRateLimiter = RateLimiter.create(m_configUtil.getLoadConfigQPS());<span class="comment">// 限流器</span></span><br><span class="line">    m_configNeedForceRefresh = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);<span class="comment">// 是否强制刷新</span></span><br><span class="line">    m_loadConfigFailSchedulePolicy = <span class="keyword">new</span> ExponentialSchedulePolicy(m_configUtil.getOnErrorRetryInterval(),<span class="comment">//1</span></span><br><span class="line">        m_configUtil.getOnErrorRetryInterval() * <span class="number">8</span>);<span class="comment">// 1 * 8;失败定时重试策略: 最小一秒,最大 8 秒.</span></span><br><span class="line">    gson = <span class="keyword">new</span> Gson();<span class="comment">// json 序列化</span></span><br><span class="line">    <span class="keyword">this</span>.trySync(); <span class="comment">// 第一次同步</span></span><br><span class="line">    <span class="keyword">this</span>.schedulePeriodicRefresh();<span class="comment">// 定时刷新</span></span><br><span class="line">    <span class="keyword">this</span>.scheduleLongPollingRefresh();<span class="comment">// 长轮询刷新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在构造方法中，就执行了 3 个本地方法，其中就包括定时刷新和长轮询刷新。这两个功能在 apollo 的 github 文档中也有介绍：</p>
<blockquote>
<p>1.客户端和服务端保持了一个长连接，从而能第一时间获得配置更新的推送。<br>   2.客户端还会定时从Apollo配置中心服务端拉取应用的最新配置。<br>  3.这是一个fallback机制，为了防止推送机制失效导致配置不更新。<br>  4.客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified。<br>  5.定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: apollo.refreshInterval来覆盖，单位为分钟。</p>
</blockquote>
<p>所以，长连接是更新配置的主要手段，然后用定时任务辅助长连接，防止长连接失败。</p>
<p>那就看看长连接和定时任务的具体代码。</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>定时任务主要由一个单 core 的线程池维护这定时任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 定时任务,单个 core. 后台线程</span></span><br><span class="line">    m_executorService = Executors.newScheduledThreadPool(<span class="number">1</span>,</span><br><span class="line">        ApolloThreadFactory.create(<span class="string">"RemoteConfigRepository"</span>, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">schedulePeriodicRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认 5 分钟同步一次.</span></span><br><span class="line">    m_executorService.scheduleAtFixedRate(</span><br><span class="line">        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            trySync();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, m_configUtil.getRefreshInterval(), m_configUtil.getRefreshInterval(),<span class="comment">// 5</span></span><br><span class="line">        m_configUtil.getRefreshIntervalTimeUnit());<span class="comment">//单位：分钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体就是每 5 分钟执行 sync 方法。我简化了一下 sync 方法，一起看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ApolloConfig previous = m_configCache.get();</span><br><span class="line">  <span class="comment">// 加载远程配置</span></span><br><span class="line">  ApolloConfig current = loadApolloConfig();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//reference equals means HTTP 304</span></span><br><span class="line">  <span class="keyword">if</span> (previous != current) &#123;</span><br><span class="line">    m_configCache.set(current);</span><br><span class="line">    <span class="comment">// 触发监听器</span></span><br><span class="line">    <span class="keyword">this</span>.fireRepositoryChange(m_namespace, <span class="keyword">this</span>.getConfig());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，拿到上一个 config 对象的引用，然后，加载远程配置，判断是否相等，如果不相等，更新引用缓存，触发监听器。</p>
<p>可以看出，关键是加载远程配置和触发监听器，这两个操作。</p>
<p>loadApolloConfig 方法主要逻辑就是通过 HTTP 请求从 configService 服务里获取到配置。大概步骤如下：</p>
<ol>
<li>首先限流。获取服务列表。然后根据是否有更新通知，决定此次重试几次，如果有更新，重试2次，反之一次。</li>
<li>优先请求通知自己的 configService，如果失败了，就要进行休息，休息策略要看是否得到更新通知了，如果是，就休息一秒，否则按照 SchedulePolicy 策略来。</li>
<li>拿到数据后，重置强制刷新状态和失败休息状态，返回配置。</li>
</ol>
<p><strong>触发监听器步骤：</strong></p>
<ol>
<li>循环远程仓库的监听器，调用他们的 onRepositoryChange 方法。其实就是 Config。</li>
<li>然后，更新 Config 内部的引用，循环向线程池提交任务—— 执行 Config 监听器的 onChange 方法。</li>
</ol>
<p>好，到这里，定时任务就算处理完了，总之就是调用 sync 方法，请求远程  configServer 服务，得到结果后，更新 Config 对象里的配置，并通知监听器。</p>
<p>再来说说长轮询。</p>
<h2 id="长连接-长轮询"><a href="#长连接-长轮询" class="headerlink" title="长连接 / 长轮询"></a>长连接 / 长轮询</h2><p>长轮询实际上就是在一个类似死循环里，不停请求 ConfigServer 的配置变化通知接口 notifications/v2，如果配置有变更，就会返回变更信息，然后向定时任务线程池提交一个任务，任务内容是执行 sync 方法。</p>
<p>在请求 ConfigServer 的时候，ConfigServer 使用了 Servlet 3 的异步特性，将 hold 住连接 30 秒，等到有通知就立刻返回，这样能够实现一个基于 HTTP 的长连接。</p>
<p>关于为什么使用 HTTP 长连接，初次接触 Apollo 的人都会疑惑，为什么使用这种方式，而不是”那种”方式？</p>
<p>下面是作者宋顺的回复：<br><img src="https://upload-images.jianshu.io/upload_images/4236553-fd8d97b7ee24aaa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>总结一下：</p>
<ol>
<li>为什么不使用消息系统？太复杂，杀鸡用牛刀。</li>
<li>为什么不用  TCP 长连接？对网络环境要求高，容易推送失败。且有双写问题。</li>
<li>为什么使用 HTTP 长轮询？性能足够，结合 Servlet3 的异步特性，能够维持万级连接（一个客户端只有一个长连接）。直接使用 Servlet 的 HTTP 协议，比单独用 TCP 连接方便。HTTP 请求/响应模式，保证了不会出现双写的情况。<strong>最主要还是简单，性能暂时不是瓶颈</strong>。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文没有贴很多的代码。因为不是一篇源码分析的文章。</p>
<p>总之，Apollo 的更新配置设计就是通过定时轮询和长轮询进行组合而来。</p>
<p>定时轮询负责调用获取配置接口，长轮询负责调用配置更新通知接口，长轮询得到结果后，将提交一个任务到定时轮询线程池里，执行同步操作——也就是调用获取配置接口。</p>
<p>为什么使用 HTTP 长轮询？ 简单！简单！简单！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>