<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>SOFA-源码分析-—-负载均衡和一致性-Hash</title></head><body>　　<div class="inner"><h2>SOFA-源码分析-—-负载均衡和一致性-Hash</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-ddb0f58a745f8600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SOFA 内置负载均衡，支持 5 种负载均衡算法，随机（默认算法），本地优先，轮询算法，一致性 hash，按权重负载轮询（不推荐，已被标注废弃）。</p>
<p>一起看看他们的实现（重点还是一致性 hash）。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>具体源码在  AbstractLoadBalancer 类中，子类需要实现 doSelect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ProviderInfo <span class="title">doSelect</span><span class="params">(SofaRequest invocation, List&lt;ProviderInfo&gt; providerInfos)</span></span>;</span><br></pre></td></tr></table></figure>
<p>随机是默认算法，RandomLoadBalancer 类是具体实现，基本是就是 providerInfos.get(random.nextInt(size)) 的逻辑，但考虑到权重，会按总权重数随机找个数字，然后这个数字会递减直到小于 0 的时候，确定那个节点。好像看起来和权重没什么关系？ 有大佬懂的可以指导一下。</p>
<p>本地优先算法，则是找本机的 localhost 进行匹配，优先选择和本机地址相同的服务，然后在这些服务列表进行随机选一个。</p>
<p>轮询就是一个个来。使用取于算法。</p>
<p>然后就是一致性 Hash 了，重点讲讲。 有必要复习一下我们之前写过的一致性 hash 算法 demo： <a href="http://thinkinjava.cn/article/89" target="_blank" rel="noopener">自己实现一个一致性 Hash 算法</a>。</p>
<p>SOFA 具体实现是 ConsistentHashLoadBalancer 类。内部维护一个 Map，每个服务对应一个选择器，这个选择器内部维护着一个 TreeMap，SOFA 会将所有节点均匀的散列在 Map 中，也就是 hash 环上，使用了虚拟节点。当根据服务的 key 获取节点的时候(如果服务列表没变)，会通过 hash 值找到比他大的那个节点，相同的请求每次找到的都是同一个节点（根据第一个参数 hash）。</p>
<p>来看看具体实现。</p>
<p>先看看 doSelect 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProviderInfo <span class="title">doSelect</span><span class="params">(SofaRequest request, List&lt;ProviderInfo&gt; providerInfos)</span> </span>&#123;</span><br><span class="line">    String interfaceId = request.getInterfaceName();</span><br><span class="line">    String method = request.getMethodName();</span><br><span class="line">    String key = interfaceId + <span class="string">"#"</span> + method;</span><br><span class="line">    <span class="keyword">int</span> hashcode = providerInfos.hashCode(); <span class="comment">// 判断是否同样的服务列表</span></span><br><span class="line">    Selector selector = selectorCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="keyword">null</span> <span class="comment">// 原来没有</span></span><br><span class="line">        ||</span><br><span class="line">        selector.getHashCode() != hashcode) &#123; <span class="comment">// 或者服务列表已经变化</span></span><br><span class="line">        selector = <span class="keyword">new</span> Selector(interfaceId, method, providerInfos, hashcode);</span><br><span class="line">        selectorCache.put(key, selector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selector.select(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据接口名和方法名从 map 中找到对应的服务选择器，如果没有，或者服务列表变了，则重新创建一个，这点和缓存的一致性 Hash 设计还是有点不一样。</p>
<p>缓存的一致性 Hash 的目的是：如果服务列表变了，比如节点的增减，那么，缓存的 key 通过相同的 hash 算法依然能够找到对应的缓存节点（最多失效一个节点的数据——如果增减一个节点）。</p>
<p>但 RPC 服务的一致性 hash 的目的是：希望相同的请求总是落在同一个节点上。</p>
<p>而这里无法确定增加的是哪一个节点，索性直接创建一个新的。</p>
<p>然后，调用选择的 select 方法返回一个服务节点。</p>
<p>先看看选择器的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Selector</span><span class="params">(String interfaceId, String method, List&lt;ProviderInfo&gt; actualNodes, <span class="keyword">int</span> hashcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interfaceId = interfaceId;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="keyword">this</span>.hashcode = hashcode;</span><br><span class="line">    <span class="comment">// 创建虚拟节点环 （默认一个provider共创建128个虚拟节点，较多比较均匀）</span></span><br><span class="line">    <span class="keyword">this</span>.virtualNodes = <span class="keyword">new</span> TreeMap&lt;Long, ProviderInfo&gt;();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo providerInfo : actualNodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num / <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] digest = messageDigest(providerInfo.getHost() + providerInfo.getPort() + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">                virtualNodes.put(m, providerInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑就是构造虚拟节点，使用 TreeMap，和我们之前实现的一样。那么虚拟节点是如何设计的呢？</p>
<p>SOFA 为每个节点分配了 128 个虚拟节点，保存在 Map 中，也就是 128 个引用指向同一个对象。这里的 hash 算法用来 md5 然后再复杂的 hash 一波，为了更加的均衡吧。</p>
<p>当使用 select 方法的时候，怎么找到相同的节点呢？</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProviderInfo <span class="title">sekectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">    ProviderInfo providerInfo = virtualNodes.get(hash);</span><br><span class="line">    <span class="keyword">if</span> (providerInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        SortedMap&lt;Long, ProviderInfo&gt; tailMap = virtualNodes.tailMap(hash);</span><br><span class="line">        <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">            hash = virtualNodes.firstKey();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hash = tailMap.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">        providerInfo = virtualNodes.get(hash);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> providerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hash 该方法第一个参数，找到比他的 hash 值大节点集合中的第一个节点，如果没有比他大的，则最小的那个节点（回到原点）。</p>
<p>标准的一致性 hash 算法。保证了每次相同的请求都会落在同一个节点上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RPC 的一致性 hash 和缓存的一致性 hash 的目的是不同的。<br>缓存的目的是：当集群中缓存节点增减的时候，服务访问相同 key 依然能够访问到相同的节点（增减造成的失效节点很少）。不会像普通的取于算法那样造成无法访问，进而引起缓存雪崩，甚至 DB 宕机。</p>
<p>而 RPC 的目的是：希望相同的请求（第一个参数相同），每次都会打在相同的节点上。</p>
<p>换个角度想想，其实都是一样的，目的都是为了相同的请求每次都访问到相同的节点。</p>
<p>好啦，关于 SOFA  的负载均衡就到这里啦。</p>
<p>bye！！！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>