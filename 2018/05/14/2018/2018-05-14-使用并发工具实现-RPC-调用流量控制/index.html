<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>使用并发工具实现-RPC-调用流量控制</title></head><body>　　<div class="inner"><h2>使用并发工具实现-RPC-调用流量控制</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RPC 服务中，每个服务的容量都是有限的，即资源有限，只能承受住给定的网络请求，所以，在设计 RPC 框架的时候，一定要考虑流量控制这个问题。而 Java 中，实现流量控制有很多中方式，今天说 2 种。</p>
<h2 id="Semaphore-实现流控"><a href="#Semaphore-实现流控" class="headerlink" title="Semaphore 实现流控"></a>Semaphore 实现流控</h2><p>代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Executor timeTask = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">  ((ScheduledExecutorService) timeTask).scheduleAtFixedRate(</span><br><span class="line">      () -&gt; semaphore.release(<span class="number">100</span> - semaphore.availablePermits()), <span class="number">1000</span>, <span class="number">1000</span>,</span><br><span class="line">      TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">  Executor pool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (semaphore.tryAcquire()) &#123;</span><br><span class="line">            callRpc(num, j);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">"call fail"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callRpc</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  System.out.println(String.format(<span class="string">"%s - %s: %d %d"</span>, <span class="keyword">new</span> Date(), Thread.currentThread(), num, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中，我们模拟了 100 个线程，每个线程无限调用 RPC。</p>
<p>同时使用另一个定时任务，定时更新 Semaphore 可用许可为 100。</p>
<p>客户端线程调用时，会尝试获取信号量，当获取成功时，才会调用调用 RPC，反之，打印失败。</p>
<p>这个小程序实现了每秒钟限制 100 个请求的 RPC 的流量控制。</p>
<h2 id="AtomicInteger-实现流控"><a href="#AtomicInteger-实现流控" class="headerlink" title="AtomicInteger 实现流控"></a>AtomicInteger 实现流控</h2><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Executor timeTask = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">  ((ScheduledExecutorService) timeTask).scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      count.getAndSet(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">  Executor pool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> num = i;</span><br><span class="line">    pool.execute(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (count.get() &gt;= <span class="number">0</span>) &#123;<span class="comment">// 快速判断，否则大量的 CAS 操作将会定时任务更新计数器 count</span></span><br><span class="line">            <span class="keyword">if</span> (count.decrementAndGet() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              callRpc(num, j);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callRpc</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  System.out.println(String.format(<span class="string">"%s - %s: %d %d"</span>, <span class="keyword">new</span> Date(), Thread.currentThread(), num, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码和上面的类似，只是使用的 API 不同，这里使用的是 CAS。通过对 CAS 递减，达到流控的目的。</p>
<p>注意，这里有一个双重判断，先判断 count.get() &gt;= 0，为什么呢？</p>
<p>如果直接使用 decrementAndGet 方法，则会使用 CAS，100 个线程并发使用 CAS ，将会导致定时任务的 CAS 操作不够及时。</p>
<p>所以，先判断，是否小于0 ，如果小于0了，就不必尝试 CAS，避免影响定时任务。</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>