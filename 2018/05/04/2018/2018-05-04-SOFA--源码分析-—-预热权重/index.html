<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>SOFA--源码分析-—-预热权重</title></head><body>　　<div class="inner"><h2>SOFA--源码分析-—-预热权重</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-ddb0f58a745f8600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SOFA-RPC 支持根据权重对服务进行预热功能，具体地址：<a href="https://github.com/alipay/sofa-rpc/wiki/Provider-Warmup-Weight" target="_blank" rel="noopener">预热权重</a>.</p>
<p>引用官方文档：</p>
<p>预热权重功能让客户端机器能够根据服务端的相应权重进行流量的分发。该功能也常被用于集群内少数机器的启动场景。利用流量权重功能在短时间内对服务端机器进行预热，然后再接收正常的流量比重。 运行机制如下： </p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-7b33cacfc6b7ba3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>1.服务端服务在启动时会将自身的预热时间，预热期内权重，预热完成后的正常权重推送给服务注册中心。如上图 ServiceB 指向 Service Registry 。</p>
<p>2.客户端在引用服务的时候会获得每个服务实例的预热权重信息。如上图 Service Registry 指向 client 。</p>
<p>3.客户端在进行调用的时候会根据服务所在地址的预热时期所对应的权重进行流量分发。如上图 client 指向 ServiceA 和 ServiceB 。 ServiceA 预热完毕，权重默认 100 ， ServiceB 处于预热期，权重为 10，因此所承受流量分别为 100%110 和 10%110 。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>该功能使用方式如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProviderConfig&lt;HelloWordService&gt; providerConfig = <span class="keyword">new</span> ProviderConfig&lt;HelloWordService&gt;() </span><br><span class="line">            .setWeight(<span class="number">100</span>) </span><br><span class="line">            .setParameter(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT,<span class="string">"10"</span>) </span><br><span class="line">            .setParameter(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME,<span class="string">"12000"</span>);</span><br></pre></td></tr></table></figure>
<p>如上，该服务的预热期为12s，在预热期内权重为10，预热期结束后的正常权重为100。如果该服务一共发布在两个机器A,B上，A机器正处于预热期内，并使用上述配置，B已经完成预热，正常权重为200。那么客户端在调用的时候，此时流量分发的比重为10：200，A机器预热结束后，流量分发比重为100：200。 在SOFABoot中，如下配置预热时间，预热期间权重和预热完后的权重即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sofa:reference</span> <span class="attr">id</span>=<span class="string">"sampleRestFacadeReferenceBolt"</span> <span class="attr">interface</span>=<span class="string">"com.alipay.sofa.endpoint.facade.SampleFacade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">sofa:global-attrs</span> <span class="attr">weight</span>=<span class="string">"100"</span> <span class="attr">warm-up-time</span>=<span class="string">"10000"</span> <span class="attr">warm-up-weight</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">sofa:binding.bolt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sofa:reference</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再来看看源码实现。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>从 demo 中看，SOFA 需要在 ProviderConfig 中配置属性，而这些属性都是保存在一个 Map 中。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">setParameter</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (parameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">           parameters = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">           parameters.remove(key);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           parameters.put(key, value);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> castThis();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当发布服务的时候，这个 Map 会被发布到注册中心。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(String appName, String serviceName, ProviderInfo providerInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOGGER.isInfoEnabled(appName)) &#123;</span><br><span class="line">        LOGGER.infoWithApp(appName, LogCodes.getLog(LogCodes.INFO_ROUTE_REGISTRY_PUB, serviceName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&#123;service : [provider...]&#125;</span></span><br><span class="line">    ProviderGroup oldGroup = memoryCache.get(serviceName);</span><br><span class="line">    <span class="keyword">if</span> (oldGroup != <span class="keyword">null</span>) &#123; <span class="comment">// 存在老的key</span></span><br><span class="line">        oldGroup.add(providerInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有老的key，第一次加入</span></span><br><span class="line">        List&lt;ProviderInfo&gt; news = <span class="keyword">new</span> ArrayList&lt;ProviderInfo&gt;();</span><br><span class="line">        news.add(providerInfo);</span><br><span class="line">        memoryCache.put(serviceName, <span class="keyword">new</span> ProviderGroup(news));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备份到文件 改为定时写</span></span><br><span class="line">    needBackup = <span class="keyword">true</span>;</span><br><span class="line">    doWriteFile();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subscribe) &#123;</span><br><span class="line">        notifyConsumerListeners(serviceName, memoryCache.get(serviceName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，提供者会将 providerInfo 的信息写到本地文件(注册中心)中。</p>
<p>而消费者则会从注册中心订阅服务列表的信息。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ProviderGroup&gt; <span class="title">subscribe</span><span class="params">(ConsumerConfig config)</span> </span>&#123;</span><br><span class="line">    String key = LocalRegistryHelper.buildListDataId(config, config.getProtocol());</span><br><span class="line">    List&lt;ConsumerConfig&gt; listeners = notifyListeners.get(key);</span><br><span class="line">    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        listeners = <span class="keyword">new</span> ArrayList&lt;ConsumerConfig&gt;();</span><br><span class="line">        notifyListeners.put(key, listeners);</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.add(config);</span><br><span class="line">    <span class="comment">// 返回已经加载到内存的列表（可能不是最新的)</span></span><br><span class="line">    ProviderGroup group = memoryCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">        group = <span class="keyword">new</span> ProviderGroup();</span><br><span class="line">        memoryCache.put(key, group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonList(group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码会被 DefaultConsumerBootstrap 调用，根据消费者的配置信息，生成一个 key，然后将消费者添加到通知列表中（当数据变化时，通知消费者，由定时任务执行）。</p>
<p>然后，从内存中取出key 对应的服务分组，并返回集合（就是提供者注册的信息）。</p>
<p>这段代码会在 AbstractCluster 的 init 方法中调用—— <code>List&lt;ProviderGroup&gt; all = consumerBootstrap.subscribe();</code>。</p>
<p>服务分组的数据结构是 ProviderInfo，是一个抽象的服务提供列表，其中包含服务的信息，比如地址，协议类型，主机地址，端口，路径，版本，动态参数，静态参数，服务状态等等，其中就包括<strong>权重</strong>。</p>
<p>获取权重的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProviderStatus status = getStatus();</span><br><span class="line">    <span class="keyword">if</span> (status == ProviderStatus.WARMING_UP) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 还处于预热时间中</span></span><br><span class="line">            Integer warmUpWeight = (Integer) getDynamicAttr(ProviderInfoAttrs.ATTR_WARMUP_WEIGHT);</span><br><span class="line">            <span class="keyword">if</span> (warmUpWeight != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> warmUpWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 getStatus 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProviderStatus <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status == ProviderStatus.WARMING_UP) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &gt; (Long) getDynamicAttr(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME)) &#123;</span><br><span class="line">            <span class="comment">// 如果已经过了预热时间，恢复为正常</span></span><br><span class="line">            status = ProviderStatus.AVAILABLE;</span><br><span class="line">            setDynamicAttr(ProviderInfoAttrs.ATTR_WARM_UP_END_TIME, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑如下：</p>
<p>获取服务状态，如果是预热状态，则获取预热状态的权重值，反之，如果不是，反之正常值（默认 100）。</p>
<p>获取状态的方法则是判断时间，如果当前时间大于预热时间，则修改状态为可用。并删除动态参数列表中的“预热时间”。</p>
<p>那么，什么时候会获取权重呢？</p>
<p>如果看过之前文章的同学肯定知道，在负载均衡的时候，会调用。</p>
<p>我们看看默认的随机均衡算法。还记得当时，楼主有个地方不是很明白，我们要根据权重随机，当时看来，并没有什么用处，今天明白了。再上一遍代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@ AbstractLoadBalancer.java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(ProviderInfo providerInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从provider中或得到相关权重,默认值100</span></span><br><span class="line">    <span class="keyword">return</span> providerInfo.getWeight() &lt; <span class="number">0</span> ? <span class="number">0</span> : providerInfo.getWeight();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取权重，默认 100.</p>
<p>再看随机算法的 doSelect 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@ RandomLoadBalancer.java</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProviderInfo <span class="title">doSelect</span><span class="params">(SofaRequest invocation, List&lt;ProviderInfo&gt; providerInfos)</span> </span>&#123;</span><br><span class="line">    ProviderInfo providerInfo = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> size = providerInfos.size(); <span class="comment">// 总个数</span></span><br><span class="line">    <span class="keyword">int</span> totalWeight = <span class="number">0</span>; <span class="comment">// 总权重</span></span><br><span class="line">    <span class="keyword">boolean</span> isWeightSame = <span class="keyword">true</span>; <span class="comment">// 权重是否都一样</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> weight = getWeight(providerInfos.get(i));</span><br><span class="line">        totalWeight += weight; <span class="comment">// 累计总权重</span></span><br><span class="line">        <span class="keyword">if</span> (isWeightSame &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; weight != getWeight(providerInfos.get(i - <span class="number">1</span>))) &#123;</span><br><span class="line">            isWeightSame = <span class="keyword">false</span>; <span class="comment">// 计算所有权重是否一样</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !isWeightSame) &#123;</span><br><span class="line">        <span class="comment">// 如果权重不相同且权重大于0则按总权重数随机</span></span><br><span class="line">        <span class="keyword">int</span> offset = random.nextInt(totalWeight);</span><br><span class="line">        <span class="comment">// 并确定随机值落在哪个片断上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            offset -= getWeight(providerInfos.get(i));</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                providerInfo = providerInfos.get(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果权重相同或权重为0则均等随机</span></span><br><span class="line">        providerInfo = providerInfos.get(random.nextInt(size));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> providerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断各个服务的权重是否相同，如果不同，进入第二个 if。</p>
<p>关键点来了，如果权重不同，那么从总的权重中，随机一个数，一次从服务列表的权重递减。知道该值小于0，那么就使用该服务。</p>
<p>这样就能<strong>大致</strong>保证权重小的被击中的几率较小。具体取决于 Java 的随机算法，但是我们还是比较相信 Java 的。</p>
<p>我们来推倒一下这个算法。</p>
<p>假设有 A， B， C， 3 个服务，每个服务默认权重 100，其中 C 现在处于预热阶段，则 C 的权重等于 10.</p>
<p>那么总权重 210。</p>
<p>如果C落在第一位，那么一定会选中C的情况是权重落在0-9之间；<br>如果C落在第二位，那么一定会选中C的情况是权重落在100-109之间；<br>如果C是在第三位，那么一定会选中C的情况是权重落在200-209；</p>
<p>符合权重。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在看来，预热权重还是挺简单的，主要在负载均衡出进行处理就行。</p>
<p>今天就到这里，bye！！！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>