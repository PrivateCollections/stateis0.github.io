<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>Java-如何获取泛型类型</title></head><body>　　<div class="inner"><h2>Java-如何获取泛型类型</h2><p>在 Java 开发中，获取泛型这种操作虽不是很常用，但有时确实必须的，比如 将Json 字符串反序列化成对象的时候。今天就来介绍这个操作。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们定义了一个类，内部有一个数据结构，泛型为 T，当我们输入一个 Json 字符串，想把这个 Json 反序列化成对象，那么此时，我们就需要知道这个泛型的类型。</p>
<p>具体代码场景如下：</p>
<p>抽象父类（包含泛型）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  T data;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(String json)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = JsonUtil.toObject(json, deSerializable());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们想在该类中输入 Json，并将字符串反序列化成对象。比如下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类定义了父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">DataClass</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String json)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(json);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据类型继承Comparable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataClass</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">DataClass</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(DataClass o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，子类定义了泛型，但获取泛型类型是在父类。</p>
<p>所以，重点在 deSerializable（） 方法的实现，我们需要一个 Class<t> 让 Json 工具能够正常序列化。</t></p>
<h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>先说结论：通过 Java 反射包的 ParameterizedType 工具获得泛型具体类型。</p>
<p>例如：下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String json = JsonUtil.toJson(<span class="keyword">new</span> DataClass());</span><br><span class="line">  Son s = <span class="keyword">new</span> Son(json);</span><br><span class="line">  Type t = s.getClass().getGenericSuperclass();</span><br><span class="line">  <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="comment">// output: cn.think.in.java.clazz.loader.generics.Base&lt;cn.think.in.java.clazz.loader.generics.DataClass&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (Type type : ((ParameterizedType) t).getActualTypeArguments()) &#123;</span><br><span class="line">      System.out.println(type);</span><br><span class="line">      <span class="comment">//output: class cn.think.in.java.clazz.loader.generics.DataClass</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们将一个对象序列化成 Json 字符串，模拟外部输入。然后呢？创建一个子类对象，得到这个 Son 的 Class 。<br>关键地方来了，调用 getGenericSuperclass 方法，这个方法的作用是：<code>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type。</code></p>
<p>所以这里会得到一个 ParameterizedTypeImpl 类型的对象。注意：这个类是 Sun 包下的，不是开源的。该类有以下几个属性：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-4f60a84bee81d18f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>Type[] 数组就是该类（我们这里是父类）的泛型，rawType 是原始类型，即 Base  的 Class 类型。而 OwnerType 返回的则是 Base 类型。</p>
<p>然后呢，判断这个 t 是不是 ParameterizedType 接口的实现类。如果是，调用 getActualTypeArguments 方法，返回一个 Type数组，即上图的 actualTypeArguments 属性。</p>
<p>而返回的 Type 数组就是父类的泛型 Class。因为 Class 实现了  Type 接口。为什么是数组呢？因为每个类可以有多个泛型。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-e704390e0702f436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>通过这样几行代码，我们就得到了泛型。当然，这种用法很少。</p>
<p>现在我们知道了如何得到泛型，那么，就将刚刚的场景中的问题解决。</p>
<p>实现反序列化方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Class&lt;T&gt; <span class="title">deSerializable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Type type = getClass().getGenericSuperclass();</span><br><span class="line">  <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">    System.out.println(parameterizedType.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> (Class&lt;T&gt;) parameterizedType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到当前类（Son）的泛型 Class，获取到泛型数组，返回第一个（因为我们只有一个泛型）泛型类型的 Class<t>。<br>然后，使用 Json 工具传入 Json 字符串和 Class<t> 类型并返回实体对象。</t></t></p>
<p>这样就能够保证编译不会错误，且高度灵活。</p>
<p>这里有一个地方需要注意：Java 的泛型是会在运行期擦除的，但并不总是擦除成 Object ，而是擦除到上限类型。<br>如果时获取接口的泛型则是调用 Class 的 getGenericInterfaces 方法得到接口集合的泛型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为历史原因，Java 的泛型一直是个痛点，但无法避免，所以使用起来确实有点麻烦。但通过 Class 类的众多反射功能，我们还是能够处理泛型的问题。</p>
<p>我们今天使用反射得到了一个类的泛型，并在父类进行处理，成功的将一个字符串反序列化成一个对象。</p>
<p>bye！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>