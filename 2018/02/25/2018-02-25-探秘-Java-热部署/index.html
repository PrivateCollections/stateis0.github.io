<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>探秘-Java-热部署</title></head><body>　　<div class="inner"><h2>探秘-Java-热部署</h2><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的 <a href="https://www.jianshu.com/p/85eba062b9c1" target="_blank" rel="noopener">深入浅出 JVM ClassLoader</a> 一文中，我们说可以通过修改默认的类加载器实现热部署，但在 Java 开发领域，热部署一直是一个难以解决的问题，目前的 Java 虚拟机只能实现方法体的修改热部署，对于整个类的结构修改，仍然需要重启虚拟机，对类重新加载才能完成更新操作。对于某些大型的应用来说，每次的重启都需要花费大量的时间成本，所以，如果能像我们之前说的那样，在不重启虚拟机的情况下更新一个类，在某些业务场景下变得十分重要。比如很多脚本语言就支持热替换，例如 PHP，只要替换了PHP 源文件，这种改动就会立即生效，且无需重启服务器。</p>
<p>今天我们就来一个简单的热部署，注意：不要小看他，这也是 JSP 支持修改的实现方式。</p>
<h1 id="1-怎么实现？"><a href="#1-怎么实现？" class="headerlink" title="1. 怎么实现？"></a>1. 怎么实现？</h1><p>在上篇文章中，我们贴了一幅图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-dbe5357dffc7d83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="热替换基本思路"></p>
<p>我们知道，一个类加载器只能加载一个同名类，在Java默认的类加载器层面作了判断，如果已经有了该类，则不再重复加载，如果强行绕过判断并使用自定义类加载器重复加载（比如调用 defineClass 方法），JVM 将会抛出 LinkageError：attempted  duplicate class definition for name。</p>
<p>但请注意，我们说同一个类加载器不可以加载两个同名的类，但不同的类加载器是可以加载同名的类的，加载完成之后，这两个类虽然同名，但不是同一个 Class 对象，无法进行转换。</p>
<p>那么我们是否可以利用这个特性，实现热部署呢？如同上图的步骤：使用自定义的类加载器，加载一个类，当需要进行替换类的时候，我们就丢弃之前的类加载器和类，使用新的类加载器去加载新的 Class 文件，然后运行新对象的方法。</p>
<p>让我们按照这个思路写段代码试试吧！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">AccountMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> ClassNotFoundException, InterruptedException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      ClassLoader loader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line"></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      Class clazz = loader.loadClass(<span class="string">"cn.think.in.java.clazz.loader.asm.Account"</span>);</span><br><span class="line">      Object account = clazz.newInstance();</span><br><span class="line">      account.getClass().getMethod(<span class="string">"operation"</span>, <span class="keyword">new</span> Class[]&#123;&#125;).invoke(account);</span><br><span class="line">      Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个类是一个 mian 方法类，该方法是一个间隔 20 秒的死循环，步骤如下：</p>
<ol>
<li>创建一个自定义的 ClassLoader 对象，加载类的步骤不遵守双亲委派模型，而是直接加载。</li>
<li>使用刚刚创建的类加载器加载指定的类。</li>
<li>得到刚刚的Class 对象，使用反射创建对象，并调用对象的 operation 方法。</li>
</ol>
<p>为什么间隔20秒呢？因为我们要在启动之后，修改类，并重新编译。因此需要20秒时间。</p>
<p>再看看 Account 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"operation..."</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类很简单，只有一个方法，就是打印 operation…字符串。</p>
<p>我们还需要一个类，干什么用呢？我们刚刚说，需要修改 Account 类，然后重新编译，为了方便，我们创建一个类，专门用于执行修改后的 Account 类，因为执行后肯定重新编译了，省的我们去命令行使用 javac 了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReCompileAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Account().operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何测试呢？</p>
<ol>
<li>启动AccountMain main 方法。会立刻打印出  operation… 字符串，并开始等待20秒。</li>
<li>修改 Account 类的字符串为 operation…..new，</li>
<li>启动 ReCompileAccount 类，目的是重新编译 Accoutn类。</li>
<li>等待 AccountMain  类的打印。</li>
</ol>
<p>不出意外的话，最后结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4236553-6c4f9504c29305c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印结果"></p>
<p>看到了吧，我们已经成功的把Accout 类修改了，并且是在不重启 JVM 的情况下，实现了热部署。就像我们刚刚说的，JSP 支持修改也是这么实现的，每一个 JSP 页面都对应着一个类加载器，当JSP 页面被修改了，就重新创建类加载器，然后使用新的类加载器加载 JSP （JSP 其实就是 Java 类）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于 ClassLoader 的原理，我们实现了 Java 层面的热部署，但大家如果自己实现一遍的话，还是觉得很麻烦，诚然，JSP 使用这种方式没什么问题，因为他是自动编译的。但如果我们自己的应用的话，难道每次修改一个类，都要重新编译一遍，然后在给定的时间里去替换？我们能不能把这些手工活都交给 JVM 呢？实际上，Tocmat 也已经通过这种方式实现过了。限于篇幅，我们将在下一篇文章中讲述。</p>
<p>good luck！！！！！</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>