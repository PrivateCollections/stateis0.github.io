<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>使用 Cglib 实现多重代理</title></head><body>　　<div class="inner"><h2>使用 Cglib 实现多重代理</h2><p>由于 Cglib 本身的设计，无法实现在 Proxy 外面再包装一层 Proxy（JDK  Proxy 可以），通常会报如下错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Caused by: java.lang.ClassFormatError: Duplicate method name <span class="string">"newInstance"</span> with signature <span class="string">"..........</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at java.lang.ClassLoader.defineClass1(Native Method)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">... 10 more</span></span><br></pre></td></tr></table></figure>
<p>错误来源代码：</p>
<p>net.sf.cglib.proxy.Enhancer#generateClass(ClassVisitor v)<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......省略代码</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下部分的字节码，每次生成 Proxy 实例都会插入。JVM 验证字节码时则会报错。</span></span><br><span class="line"><span class="keyword">if</span> (useFactory || currentData != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] keys = getCallbackKeys();</span><br><span class="line">    emitNewInstanceCallbacks(e);</span><br><span class="line">    emitNewInstanceCallback(e);</span><br><span class="line">    emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">    emitGetCallback(e, keys);</span><br><span class="line">    emitSetCallback(e, keys);</span><br><span class="line">    emitGetCallbacks(e);</span><br><span class="line">    emitSetCallbacks(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 dump 出来的字节码查看则更为直观：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-24e92aef6962fa1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-712ae04119ddbf3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>生成的字节码中，newInstance 方法是重复的。</p>
<p>dump 方法： <code>System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;./&quot;);</code></p>
<h2 id="如何处理？"><a href="#如何处理？" class="headerlink" title="如何处理？"></a>如何处理？</h2><p>实现多重代理，有一种蹩脚的方法，例如 JDK 和 Cglib 组合使用。或者你直接使用 JDK 代理。但有时候，针对类的操作还行不通。</p>
<p>笔者参考 Spring 的做法，实现了一个简单的多重代理。</p>
<p>Spring 的场景是：一个目标方法被多个 AOP 拦截，此时就需要多重代理。</p>
<p>Spring 创建代理的代码位于 ：org.springframework.aop.framework.CglibAopProxy#getProxy</p>
<p>Spring  AOP 拦截器类：org.springframework.aop.framework.CglibAopProxy.DynamicAdvisedInterceptor</p>
<p>该类的 intercept 方法是实现多重代理的核心。</p>
<p>每次调用目标方法，都会根据目标方法，和目标方法的多个拦截点生成一个调用对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成调用对象</span></span><br><span class="line">CglibMethodInvocation c = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy);</span><br><span class="line"><span class="comment">// 调用 </span></span><br><span class="line">c.proceed();</span><br></pre></td></tr></table></figure>
<p>然后调用父类  proceed 方法，其实就是一个过滤器模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">	<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">		InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">				(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">		<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Skip this interceptor and invoke the next in the chain. 递归.</span></span><br><span class="line">			<span class="keyword">return</span> proceed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意最后一行，这里就是调用拦截点的 invoke 方法，这个拦截点的具体实现类：AspectJAroundAdvice。</p>
<p>看下他的 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;</span><br><span class="line">      <span class="comment">// AOP 里熟悉的 ProceedingJoinPoint 参数!!!!</span></span><br><span class="line">	ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">	JoinPointMatch jpm = getJoinPointMatch(pmi);</span><br><span class="line">	<span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，我们在业务中编写 AOP 拦截代码时，都会接触到这个 ProceedingJoinPoint 参数，然后调用他的 proceed 方法调用目标方法。</p>
<p>这个 ProceedingJoinPoint 类的 proceed 方法最终会回调 DynamicAdvisedInterceptor 对的 proceed 方法。直到所有的拦截点全部执行完毕。最终执行目标类的方法。</p>
<p>所以，你设置的每个被拦截的方法，如果这个方法会被拦截多次，那么就会有多个 MethodInterceptor（不是 cglib 的）实例形成调用链。然后通过  ProceedingJoinPoint 传递给你拦截使用。</p>
<p>铺垫了这么多，我们自己来实现一个简单的，不能像 Spring 这么复杂！！！！</p>
<h2 id="简单实现-Cglib-多重代理"><a href="#简单实现-Cglib-多重代理" class="headerlink" title="简单实现 Cglib 多重代理"></a>简单实现 Cglib 多重代理</h2><p>先说一下思路：事实上很简单，只需要再拦截器里放一个过滤器链即可，用户在过滤器里拦截多重调用。这些拦截器，就像你加 @Around 注解的方法，只不过我们这里没有 Spring 那么方便而已。</p>
<p>画个 UML 图 ：</p>
<p><img src="https://user-images.githubusercontent.com/24973360/46510651-f2372400-c87c-11e8-91db-a094e55219f4.png" alt></p>
<p>代码如下：</p>
<p>Test.java &amp; SayHello.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object proxy = ProxyFactory.create().getProxy(<span class="keyword">new</span> SayHello());</span><br><span class="line">        proxy.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello cglib !"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProxyFactory.java &amp; Interceptor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProxyFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProxyFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object origin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        en.setSuperclass(origin.getClass());</span><br><span class="line">        List&lt;Chain.Point&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Point1());</span><br><span class="line">        list.add(<span class="keyword">new</span> Point2());</span><br><span class="line">        en.setCallback(<span class="keyword">new</span> Interceptor(<span class="keyword">new</span> Chain(list, origin)));</span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">        Chain chain;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Interceptor</span><span class="params">(Chain chain)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.chain = chain;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> chain.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Chain.java &amp; Point.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Point&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chain</span><span class="params">(List&lt;Point&gt; list, Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">if</span> (++index == list.size()) &#123;</span><br><span class="line">            result = (target.toString());</span><br><span class="line">            System.err.println(<span class="string">"Target Method invoke result : "</span> + result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Point point = list.get(index);</span><br><span class="line">            result = point.proceed(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="function">Object <span class="title">proceed</span><span class="params">(Chain chain)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Point1.java &amp; Point2.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point1</span> <span class="keyword">implements</span> <span class="title">Chain</span>.<span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(Chain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"point 1 before"</span>);</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        Object result = chain.proceed();</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"point 1 after"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point2</span> <span class="keyword">implements</span> <span class="title">Chain</span>.<span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(Chain chain)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"point 2 before"</span>);</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        Object result = chain.proceed();</span><br><span class="line">        Sleep.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"point 2 after"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 Test main 结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-a140462f4b6fa154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>符合预期。</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>