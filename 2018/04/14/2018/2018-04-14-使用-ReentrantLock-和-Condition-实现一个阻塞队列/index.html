<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>使用-ReentrantLock-和-Condition-实现一个阻塞队列</title></head><body>　　<div class="inner"><h2>使用-ReentrantLock-和-Condition-实现一个阻塞队列</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从之前的阻塞队列的源码分析中，我们知道，JDK 中的阻塞队列是使用 ReentrantLock 和  Condition 实现了，我们今天来个简易版的。代码如下：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> ConditionObject notFull = (ConditionObject) lock.newCondition();</span><br><span class="line">  <span class="keyword">final</span> ConditionObject notEmpty = (ConditionObject) lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 当数组满了</span></span><br><span class="line">      <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">        <span class="comment">// 释放锁，等待</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 放入数据</span></span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="comment">// 如果到最后一个位置了,下标从头开始,防止下标越界</span></span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) &#123;</span><br><span class="line">        <span class="comment">// 从头开始</span></span><br><span class="line">        putptr = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对 count ++ 加加</span></span><br><span class="line">      ++count;</span><br><span class="line">      <span class="comment">// 通知 take 线程,可以取数据了,不必继续阻塞</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 如果数组没有数据,则等待</span></span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取数据</span></span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="comment">// 如果到数组尽头了,就从头开始</span></span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) &#123;</span><br><span class="line">        <span class="comment">// 从头开始</span></span><br><span class="line">        takeptr = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将数量减1</span></span><br><span class="line">      --count;</span><br><span class="line">      <span class="comment">// 通知阻塞的 put 线程可以装填数据了</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>其实，这并不是我写的，而是 Condition 接口的 JavaDoc 文档中写的。并且文档中说，请不要再次实现这个队列，因为 JDK 内部已经是实现了。原话如下：</strong></p>
<blockquote>
<p> (The {@link java.util.concurrent.ArrayBlockingQueue} class provides  this functionality, so there is no reason to implement this sample usage class.)</p>
</blockquote>
<p>楼主只是觉得这个代码写的挺好的，所以分享一下，其中关键的还是 Condition 和重入锁，重入锁的核心源码我们已经看过了，今天来看看 Condition 的源码。所以我们今天使用了这个代码作为一个入口。</p>
<p>可以看到，Condition 的重要方法就是 await 和 signal，类似 Object 类的 wait 和 notify 方法。</p>
<p>我们后面会详细讲讲这两个方法的实现。</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>