<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>并发编程-——-源码分析公平锁和非公平锁</title></head><body>　　<div class="inner"><h2>并发编程-——-源码分析公平锁和非公平锁</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ReentrantLock 提供了公平锁和非公平锁，只需要在构造方法中使用一个 <code>boolean</code> 参数即可。默认非公平锁。</p>
<p>今天从源码层面看看区别和具体实现。</p>
<h2 id="1-类-UML-图"><a href="#1-类-UML-图" class="headerlink" title="1. 类 UML 图"></a>1. 类 UML 图</h2><p><img src="https://upload-images.jianshu.io/upload_images/4236553-72bf4f94efeac073.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>ReentrantLock</code> 内部有一个抽象类 <code>Sync</code>，继承了 AQS。</p>
<p>而公平锁的实现就是 <code>FairSync</code>，非公平锁的实现就是 <code>NodFairSync</code>。</p>
<p>两把锁的区别在于<code>lock</code> 方法的实现。</p>
<h2 id="2-公平锁-lock-方法实现"><a href="#2-公平锁-lock-方法实现" class="headerlink" title="2. 公平锁 lock 方法实现"></a>2. 公平锁 lock 方法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的是 AQS 的<code>acquire</code>方法，熟悉 AQS 的同学都知道，AQS 会回调子类的 <code>tryAcquire</code> 方法，看看公平锁的<code>tryAcquire</code>实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说下逻辑：</p>
<ol>
<li>获取 state 变量，如果是 0，说明锁可以获取。</li>
<li><strong>判断 AQS 队列中是否有等待的线程</strong>，如果没有，就使用 CAS 尝试获取。获取成功后，将 CLH 的持有线程修改为当前线程。</li>
<li>重入锁逻辑。</li>
<li>如果失败，返回 false， AQS 会将这个线程放进队列，并挂起。</li>
</ol>
<p>注意上面的第二步：<strong>判断 AQS 队列中是否有等待的线程</strong>。</p>
<blockquote>
<p>这就是公平的体现。</p>
</blockquote>
<p>再看看非公平锁的区别。</p>
<h2 id="3-非公平锁-lock-方法实现"><a href="#3-非公平锁-lock-方法实现" class="headerlink" title="3. 非公平锁 lock 方法实现"></a>3. 非公平锁 lock 方法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock  方法就不同了，很冲动的一个方法，直接使用 CAS 获取锁，如果成功了，就设置锁的持有线程为自己。很快速。所以默认使用了非公平锁。</p>
<p>如果失败了，就调用 AQS 的 <code>acquire</code> 方法。当然，我们看的还是<code>tryAcquire</code>方法，在上面的代码中，<code>tryAcquire</code>方法调用了父类<code>Sync</code> 的 <code>nonfairTryAcquire</code>，为什么在父类中呢？</p>
<p>在<code>ReentrantLock</code> 的 <code>tryLock</code>方法中，也调用了该方法。因为这个方法是快速返回的。该方法不会让等待时间久的线程获取锁。符合 <code>tryLock</code> 的设计。</p>
<p>方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法相比较公平锁的 <code>tryAcquire</code>方法，少了一步<strong>判断 AQS 队列中是否有等待的线程</strong>的操作。</p>
<p>他要做的就是直接抢锁，不让给队列里那些等待时间长的。</p>
<p>抢不到再进入队列。等待他的前置节点唤醒他。这个过程是公平的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><code>ReentrantLock</code>中的公平锁和非公平锁的区别就在于：调用 <code>lock</code> 方法获取锁的时候 <code>要不要判断 AQS 队列中是否有等待的线程</code>，公平锁为了让每一个线程都均衡的使用锁，就需要判断，如果有，让给他，非公平锁很霸道，不让不让就不让。</p>
<p>但如果失败了，进入队列了，进会按照 AQS 的逻辑来，整体顺序就是公平的。</p>
<p>还有个注意的地方就是：<code>ReentrantLock</code> 的 <code>tryLock（无超时机制）</code> 方法使用的非公平策略。符合他的设计。</p>
<p>而 <code>tryLock(long timeout, TimeUnit unit)</code> 方法则会根据 Sync 的具体实现来调用。不会冲动的调用 <code>nonfairTryAcquire</code> 方法。</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>