<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.ico"><title>并发编程——详解-AQS-CLH-锁</title></head><body>　　<div class="inner"><h2>并发编程——详解-AQS-CLH-锁</h2><ol>
<li>从 acquire 方法开始 —— 获取</li>
<li>为什么 AQS 需要一个虚拟 head 节点</li>
<li>reelase 方法如何释放锁</li>
<li>总结</li>
</ol>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS 是 JUC 中的核心，其中封装了资源的获取和释放，在我们之前的  <a href="http://thinkinjava.cn/article/50" target="_blank" rel="noopener">并发编程之 AQS 源码剖析</a> 文章中，我们已经从 ReentranLock 那里分析了锁的获取和释放。但我有必要再次解释 AQS 的核心 CLH 锁。</p>
<p>这里引用一下别人对于 CLH 的解释：</p>
<blockquote>
<p>CLH CLH(Craig, Landin, and Hagersten  locks): 是一个自旋锁，能确保无饥饿性，提供先来先服务的公平性。</p>
</blockquote>
<blockquote>
<p>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
</blockquote>
<p>Java AQS 的设计对 CLH 锁进行了优化或者说变体。</p>
<p>我们还是从代码开始说起吧。</p>
<h2 id="1-从-acquire-方法开始-——-获取"><a href="#1-从-acquire-方法开始-——-获取" class="headerlink" title="1. 从 acquire 方法开始 —— 获取"></a>1. 从 acquire 方法开始 —— 获取</h2><p>acquire 方法是获取锁的常用方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 当 tryAcquire 返回 true 就说明获取到锁了，直接结束。</span></span><br><span class="line">	<span class="comment">// 反之，返回 false 的话，就需要执行后面的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要子类的 tryAcquire 方法返回 false，那么就说明获取锁事变，就需要将自己加入队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个独占类型的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果 tail 节点不是 null，就将新节点的 pred 节点设置为 tail 节点。</span></span><br><span class="line">    <span class="comment">// 并且将新节点设置成 tail 节点。</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 tail 节点是  null，或者 CAS 设置 tail 失败。</span></span><br><span class="line">    <span class="comment">// 在 enq 方法中处理</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将自己加入了尾部，并更新了 tail 节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果 tail 是 null，就创建一个虚拟节点，同时指向 head 和 tail，称为 初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果不是 null</span></span><br><span class="line">        	<span class="comment">// 和 上个方法逻辑一样，将新节点追加到 tail 节点后面，并更新队列的 tail 为新节点。</span></span><br><span class="line">        	<span class="comment">// 只不过这里是死循环的，失败了还可以再来 。</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enq 方法的逻辑是什么呢？当 tail 是 null（没有初始化队列），就需要初始化队列了。CAS 设置  tail 失败，也会走这里，需要在 enq 方法中循环设置 tail。直到成功。</p>
<p>注意：这里会创建一个<strong>虚拟节点。</strong></p>
<h2 id="2-为什么-AQS-需要一个虚拟-head-节点"><a href="#2-为什么-AQS-需要一个虚拟-head-节点" class="headerlink" title="2. 为什么 AQS 需要一个虚拟 head 节点"></a>2. 为什么 AQS 需要一个虚拟 head 节点</h2><p>为什么要创建一个虚拟节点呢？</p>
<p>事情要从 Node 类的 waitStatus 变量说起，简称 ws。每个节点都有一个 ws 变量，用于这个节点状态的一些标志。初始状态是 0。如果被取消了，节点就是 1，那么他就会被 AQS 清理。</p>
<p>还有一个重要的状态：SIGNAL —— -1，表示：当当前节点释放锁的时候，需要唤醒下一个节点。</p>
<p>所有，每个节点在休眠前，都需要将前置节点的 ws 设置成 SIGNAL。<strong>否则自己永远无法被唤醒</strong>。</p>
<p>而为什么需要这么一个 ws 呢？—— 防止重复操作。假设，当一个节点已经被释放了，而此时另一个线程不知道，再次释放。这时候就错误了。</p>
<p>所以，需要一个变量来保证这个节点的状态。而且修改这个节点，必须通过 CAS 操作保证线程安全。</p>
<p>So，回到我们之前的问题：为什么要创建一个虚拟节点呢？</p>
<p>每个节点都必须设置前置节点的 ws 状态为 SIGNAL，所以必须要一个前置节点，而这个前置节点，实际上就是当前持有锁的节点。</p>
<p>问题在于有个边界问题：<strong>第一个节点怎么办？</strong>他是没有前置节点的。</p>
<blockquote>
<p>那就创建一个假的。</p>
</blockquote>
<p>这就是为什么要创建一个虚拟节点的原因。</p>
<p>总结下来就是：<strong>每个节点都需要设置前置节点的 ws 状态（这个状态为是为了保证数据一致性），而第一个节点是没有前置节点的，所以需要创建一个虚拟节点</strong>。</p>
<p>回到我们的 acquireQueued 方法证实一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里返回的节点是新创建的节点，arg 是请求的数量</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        	<span class="comment">// 找上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果上一个节点是 head ，就尝试获取锁</span></span><br><span class="line">            <span class="comment">// 如果 获取成功，就将当前节点设置为 head，注意 head 节点是永远不会唤醒的。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在获取锁失败后，就需要阻塞了。</span></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire ---&gt; 检查上一个节点的状态，如果是 SIGNAL 就阻塞，否则就改成 SIGNAL。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有 2 个逻辑：</p>
<ol>
<li>如何将自己挂起？</li>
<li>被唤醒之后做什么？</li>
</ol>
<p>先回答第二个问题： 被唤醒之后做什么？</p>
<p>尝试拿锁，成功之后，将自己设置为 head，断开和 next 的连接。</p>
<p>再看第二个问题：如何将自己挂起？</p>
<p>注意：挂起自己之前，需要将前置节点的 ws 状态设置成 SIGNAL，告诉他：你释放锁的时候记得唤醒我。</p>
<p>具体逻辑在 shouldParkAfterFailedAcquire 方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//  如果他的上一个节点的 ws 是 SIGNAL，他就需要阻塞。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    	<span class="comment">// 阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 前任被取消。 跳过前任并重试。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        	<span class="comment">// 将前任的前任 赋值给 当前的前任</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将前任的前任的 next 赋值为 当前节点</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    	<span class="comment">// 如果没有取消 || 0 || CONDITION || PROPAGATE，那么就将前任的 ws 设置成 SIGNAL.</span></span><br><span class="line">    	<span class="comment">// 为什么必须是 SIGNAL 呢？</span></span><br><span class="line">    	<span class="comment">// 答：希望自己的上一个节点在释放锁的时候，通知自己（让自己获取锁）</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重来</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的主要逻辑就是将前置节点的状态修改成 SIGNAL。其中如果前置节点被取消了，就跳过他。</p>
<p>那么肯定，在前置节点释放锁的时候，肯定会唤醒这个节点。看看释放的逻辑吧。</p>
<h2 id="3-reelase-方法如何释放锁"><a href="#3-reelase-方法如何释放锁" class="headerlink" title="3. reelase 方法如何释放锁"></a>3. reelase 方法如何释放锁</h2><p>先来一波代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 所有的节点在将自己挂起之前，都会将前置节点设置成 SIGNAL，希望前置节点释放的时候，唤醒自己。</span></span><br><span class="line">        <span class="comment">// 如果前置节点是 0 ，说明前置节点已经释放过了。不能重复释放了，后面将会看到释放后会将 ws 修改成0.</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个方法的判断就可以看出，head 必须不等于 0。为什么呢？当一个节点尝试挂起自己之前，都会将前置节点设置成 SIGNAL -1，就算是第一个加入队列的节点，在获取锁失败后，也会将虚拟节点设置的 ws 设置成 SIGNAL。</p>
<p>而这个判断也是防止多线程重复释放。</p>
<p>那么肯定，在释放锁之后，肯定会将 ws 状态设置成 0。防止重复操作。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="comment">// 将 head 节点的 ws 改成 0，清除信号。表示，他已经释放过了。不能重复释放。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果 next 是 null，或者 next 被取消了。就从 tail 开始向上找节点。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从尾部开始，向前寻找未被取消的节点，直到这个节点是 null，或者是 head。</span></span><br><span class="line">        <span class="comment">// 也就是说，如果 head 的 next 是 null，那么就从尾部开始寻找，直到不是 null 为止，找到这个 head 就不管了。</span></span><br><span class="line">        <span class="comment">// 如果是 head 的 next 不是 null，但是被取消了，那这个节点也会被略过。</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 head.next 这个节点。</span></span><br><span class="line">    <span class="comment">// 通常这个节点是 head 的 next。</span></span><br><span class="line">    <span class="comment">// 但如果 head.next 被取消了，就会从尾部开始找。</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 ws 小于 0，我们假设是 SIGNAL，就修改成 0.  证实了我们的想法。</p>
<p>如果他的 next 是 null，说明 next 取消了，那么就从尾部开始向上寻找（不从尾部也没办法）。当然找的过程中，也跳过了失效的节点。</p>
<p>最后，唤醒他。</p>
<p>唤醒之后的逻辑是什么样子的还记得吗？</p>
<p>复习一下：拿锁，设置自己为 head，断开前任 head 和自己的连接。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>AQS 使用的 CLH 锁，需要一个虚拟 head 节点，这个节点的作用是防止重复释放锁。当第一个进入队列的节点没有前置节点的时候，就会创建一个虚拟的。</p>
<p>来一幅图尝试解释 AQS 吧：</p>
<ol>
<li><p>新增节点时<br><img src="https://upload-images.jianshu.io/upload_images/4236553-d84d01082e8d1765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>更新 tail </p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-73807009865edd6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="3">
<li>唤醒节点时，之前的 head 取消了</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/4236553-b7ca9dc21e29bc6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>